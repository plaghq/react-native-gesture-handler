{"version":3,"sources":["EventManager.ts"],"names":["EventManager","constructor","view","activePointersCounter","onPointerDown","_event","_sourceEvent","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerAdd(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerUp(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerRemove(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerMove(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerLeave(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {} // called only when pointer is pressed (or touching)\n  protected onPointerEnter(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {} // called only when pointer is pressed (or touching)\n  protected onPointerCancel(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerMoveOver(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n  protected onPointerMoveOut(\n    _event: AdaptedEvent,\n    _sourceEvent?: TouchEvent | PointerEvent\n  ): void {}\n\n  public setOnPointerDown(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(\n    callback: (\n      event: AdaptedEvent,\n      sourceEvent?: TouchEvent | PointerEvent\n    ) => void\n  ): void {\n    this.onPointerMoveOut = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"]}